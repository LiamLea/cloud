###############################################################################
zookeeper

保证事物的一致性,相当于交警,防止程序之间抢占资源(zookeeper是给程序使用的)
应用场景: 集群分布式锁
          集群统一命名
          分布式协调服务

角色:
  leader    //相当于master,与所有foller进行内部数据交换
  follwer   //参与投票
  observer  //相当于foller,只是不参与投票,因为投票多,会影响集群的性能

工作原理:
  leader是通过选取产生的,必须获得超过一半的票数(总票数不会因为有主机宕机而变少)
  所需至少需要3台主机才能实现可高用,当一台宕机后,可以选举出新的leader
  读操作,每个节点都可以单独相应
  写操作,需要发给leader,然后发起投票

###############################################################################
部署zookeeper

1.装包

2.所有主机修改配置文件:zoo.cfg
#添加,如果是observer在后面声明
#2888设置的是leader监听的端,3888是非leader监听的端口

  server.id号=主机名:2888:3888[:observer]   
  ...

3.根据配置文件中的datadir项创建数据目录:zookeeper

4.设置各主机的id号
  echo id号 > zookeeper/myid

5.启动各个节点
  zookeeper/bin/zkServer.sh start

6.验证
  nc 主机名 2181
  jps
  zookeeper/bin/zkServer.sh status   

7.编写查看集群状态的脚本:zastats.sh
#!/bin/bash

function getzkstat(){
  exec 2>/dev/null                        //将错误信息都扔掉
  exec 8<>/dev/tcp/$1/2182                //将后面的文件设置为8号的输入和输出
                                      //后面的文件表示一个socket,协议为tcp,主机名为$1,端口号为2182
  echo stat >& 8                         //通过socket发送stat指令,获取集群的状态
  message=`cat <& 8 | grep -P "^Mode:"`
  echo -e "$1\t${message:-Mode:NULL}"    //如果message没有值,则输出Mode:NULL
  exec 8<& -                             //将8号的输入关闭
}
for i in $@
do
  getzkstat $i
done

###############################################################################
kafka

分布式的消息系统,实现异步通信(相当于中介的身份),缓冲,解耦等功能
kafaka通过zookeeper管理集群,所以要先搭好zookeeper集群

一.角色:
  producer    //生产者,负责发布消息
  consumer    //消费者,负责读取处理消息
  topic       //消息类别
  broker      //一台kafka服务器就是一个broker

二.部署kafka

1.所有主机修改配置文件:server.properties
  broker.id=数字          //每个主机不同
  zookeeprt.connect=主机1:2181,主机2:2181   //可以多写几台

2.所有主机启动kafkaf服务
  bin/kafka-server-start.sh -daemon config/server.properties

3.验证(需要用写好的程序进行验证)
  jps

(1)在某一个主机上创建一个topic
   

###############################################################################
hadoop的高可用集群(实现NameNode和ResourceManager的高可用

解决方案:需要让每一个DataNode都知道两个NameNode的位置
         并把块信息和心跳包发送给Active和standby这两个NameNode
         为了让Standby Node和Active Node保持同步,这两个NameNode都与JNS进程保持通信
         每当Active Node更新了映射空间,就会将变更日志发给JNS,然后standby Node进行同步

###############################################################################

