###############################################################################

ingreess controller 是一个pod，用作七层代理

可以共享宿主机的网路命名空间，则可以直接访问该pod（不需要经过service了），然后该pod直接进行调度

共享宿主机的网络名称空间就意味着，该pod只能通过该宿主机访问到，
解决方法是利用daemonset在指定的某些宿主机上运行该pod，就可以实现高可用性

还有一种常用的解决方法是，利用service代理到ingress controller（即下面的整个流程），不直接共享宿主机的网络名称空间

后端pod，由service进行分类（一个service对应一类pod）
ingress会关联相应的service，从而能够知道 有哪些pod和 pod与service绑定的端口，从而能够将一类请求调度到这一类pod上

ingress会将后端pod的信息注入到ingress controller配置中

整个流程：
  外部（或内部）流量 -> service -> ingress controller -> 后端pod（这里pod由service分类）

###############################################################################

1.创建名称空间：ingress-nginx

2.创建ingress controller

3.创建service，代理ingress controller，并绑定node上的端口，使外部能够访问

4.创建ingress，对ingress controller进行配置

###############################################################################
部署ingress nginx controller

在kubenetes项目下（https://github.com/kubernetes）
找到名为ingress nginx的项目
安装说明在deploy目录下

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml

###############################################################################
Ingress资源

#把配置注入到ingress controller中（当创建了Ingress资源，就会自动注入到相应类型的ingress controller中，不需要明确指定）
#当后端pod的ip地址改变了，ingress就会相应修改ingress controller中的配置
#当删除Ingress资源，注入到ingress controller中的配置也会被删除

apiversion: xx
kind: Ingress
metadata:
  name: xx
  namespace: xx         //跟后端的pod在同一个名称空间中，而不是ingress-nginx
  annotations: 
	kubernetes.io/ingress.class: "nginx"		//不能省略，指明使用nginx实现的ingress
	kubernetes.io/tls-acme: "false"				//指明是否使用tls认证
spec:
  rules:
  - host: xx				//匹配虚拟主机（即访问的目标主机），不设置这一项，匹配所有请求继续进行规则判断
	http:
	  paths:
	  - path: xx			//根据url，转发请求
	    backend:
		  serviceName: xx	//后端的pod是由该service代理的pod
		  servicePort: xx	//指定service端口，其实就是确定后端的pod端口（实际不从service走，只是用于映射）

###############################################################################