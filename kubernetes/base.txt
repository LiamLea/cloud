###############################################################################
基础架构（master/node架构，master一般设为3个）

1.master核心组件
  api server                         //是整个集群对外的接口
  scheduler 	                     //负责调度资源
  controller-manager                 //用于监控控制器，控制器有多种，某类控制器用于监控pod（即容器） 

2.node核心组件
  kubelet                            //管理pod，接收和执行master的任务
  docker                             //容器引擎
  kube-proxy                         //管理service，当service发生变化或与service相关联的pod发生变化，kube-proxy都会修改iptables规则
                                     //与api server进行通信
                                     //每个pod发生地址改变后，变化后的结果保存在api server中，然后api server会通知kube-proxy
                                     //kube-proxy会修改该kube-proxy所在节点的iptables规则

3.存储组件（一般放在master上）
  etcd                               //master的共享存储，存储k8s的资源
  
4.核心附件

（1）coredns                         
  每当添加一个资源或者修改资源，都会更新dns记录，使得能够通过域名解析到相应资源
  资源的域名：NAME.NAMESPACE.DOAMIN
  默认的DOMAIN为svc.cluster.local
#pod的域名有点特殊需要跟上service的名称：
#	NAME.SERVICE_NAME.NAMESPACE.DOMAIN
  
（2）heapster

（3）dashboard

（4）ingress controller

5.网络组件（有很多，选择其中一个即可）
  flannel                            //网络配置
  calico                             //网络配置，网络策略（网络策略可以用来设置隔离pod的策略）
  canel                              //将flannel和calico结合起来（flannel提供网络配置，calico提供网络策略）

###############################################################################
基础概念

  pod                               //是kubernetes最基本的操作单元,一个pod是一个进程,内部封装了多个紧密相关的容器
                                    //类似一个虚拟机，里面的容器共享net、UTS、ipc命令空间（user、mnt、pid相互隔离）
                                    //同一个pod里的容器能共享存储卷（类似虚拟机的磁盘）
									//为什么能够实现上面两种特性：每个pod中有一个基础架构容器（叫pause，其他容器共享该容器的net，UTS，ipc空间和存储卷等）
                                    //一般一个pod只放一个容器
                                    //一个pod里的所有容器只能运行在一个node上
#有两种类型：
#  自主式pod：不受控制器控制，即删除了不会再创建
#  由控制器控制的pod，会控制pod的副本数量，多了删除，少了创建

  controller                        //控制器有多种类型，用于管理相应资源
                                    //pod控制器，用于管理pod，比如某个pod挂了，控制器会再创建一个
  service                           //通过关联pod的控制器，代理该控制器管理的pod，即为pod提供固定访问端点
                                    //通过标签选择器与后端的pod相关联
                                    //通过宿主机的iptables规则，将相应请求转发给相应的pod
                                    //比如pod1需要访问pod2，请求会被交给docker的网关，然后根据iptables的规则进行转发，则这里的iptables规则提供的就是service服务
  label selector                    //用于管理大量的pod，通过pod的元数据（即给容器打上label），对pod进行管理
#许多资源支持内嵌字段定义其使用的标签选择器：
#  matchLabels:                                  //直接使用键值对对标签过滤
#  matchExpressions: {key:"KEY",operator:"OPERATOR",values:[VAL1,VAL2,...]     //基于给定的表达式对标签过滤
#OPERATOR可以为: 
#  In，NotIn                                  //values列表必须为非空
#  Exists，NotEXists                          //values列表必须为空

###############################################################################
网络架构

1.有三种网络
  节点网络
  集群网络（即service网络，虚拟的网络，存在于iptables规则中）
  pod网络

2.三种通信
  lo                       //同一个pod内的多个容器间通信
  overlay                 //各pod间通信，隧道模式
  通过iptables规则        //pod与service之间的通信

###############################################################################
进阶操作

1.kubectl api-versions		//列出所有可用的apiVersion

（1）apiVersion的结构

	group/verison	
#特列是核心群组中的：v1

（2）url中的路径

	apis/GROUP/VERSION/RESOURCE	
#比如：apis/apps/v1/namespaces/default/deployment
#列出default命名空间中的所有deployment控制器

#特列：核心群组
#比如：api/v1/namespace
#列出所有的命令空间

2.在某台master上开启代理
  kubectl proxy --address="0.0.0.0" --port=8080 --accept-hosts='^.*' --accept-paths='^.*'

#之后就可以利用url获得相关资源
#比如：
#	curl 127.0.0.1:8080/api/v1/namespaces

###############################################################################
kubectl（apiserver的客户端程序，是k8s集群的管理入口）

一.管理pods

1.创建pods
  kubectl run NAME \
            --image=xx \                  //NAME为给pod控制器的名字
            --replicas=xx                 //replicas指明副本数，至少为1，即只有1个容器
	
  kubectl create ... --dry-run -o yaml			//可以列出创建某个资源的基础框架

2.动态扩容和缩容pods
  kubectl scale --relicas=xx 控制器名

3.升级镜像
  kubectl set image deployment 控制器名 容器名=新的镜像名          //容器名可以通过kubectl describe pod xx查看 

4.在某个pod执行指令                                                                   
  kubectl exec NAME [-c xx] [-it] -- 命令       //NAME：pod名称
                                                //-c 指明该pod中具体的容器，当pod中有多个容器时使用

二.创建service（为pods提供固定访问点，之后，就可以直接访问该service，从而访问到相应的pod，因为pod的地址可能变化）
  kubectl expose TYPE NAME \              //TYPE：控制器的类型，NAME：控制器名字必须是已存在的
                  --name=服务名字 \
                  --port=xx \             //service的端口号
                  --target-port=xx        //target-port为容器的端口号

三.查询操作
1.kubectl get cs                   //cs：component status，获取改节点上的组件状态信息

2.kubectl get nodes             //获取各节点的信息

3.kubectl get ns                  //获取集群已有的名称空间

4.kubectl get pods 
				   --all-nampspace	 	//获取所有命名空间下的pod
                   -n xx              	//-n指明名称空间，不加-n，默认是default名称空间
                   -o wide          	//-o指明输出格式，wide输出扩展信息，包括该pod在哪个节点上
                   -l xx=xx        		//过滤含有xx这个标签且标签值为xx的pods，也可以-l xx直接过滤含有xx标签的pods  
#标签有两种关系判断：
#  等值关系：=    !=
#  集合关系：KEY in (VALUE1,VALUE2,...)   
#                  KEY not in (VALUE1,...)
#                  !KEY                                                                                                    

5.kubectl get svc               //svc：services

6.kubectl describe TYPE NAME      //TYPE：资源类型，NAME：资源名称，查看某个资源的详细信息

四.管理标签
1.kubectl label TYPE NAME xx1=xx ... xxn=xx       //给某个资源打标签


###############################################################################