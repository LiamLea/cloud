###############################################################################

1.REST架构：
  representation state transfer，表现层状态转移
  本质：URL定义资源，用HTTP方法处理资源

2.利用ansible执行脚本的排错方法： 
  加上参数-vvv

3.执行脚本最好使用：bash	//杀死这个bash，整个脚本就会停止

4.脚本的内容都放在后台执行了，让脚本不放在后台，可以在最后加上：wait

5.查看mysql使用的配置文件
  ps aux | grep mysql       //如果有basedir，则配置文件就在该目录下

6.net.ipv4.conf.all.rp_filter=0     
  reverse path filter，反向路径过滤

原理：
  一台主机（或路由器）从接口A收到一个包，其源地址和目的地址分别是10.3.0.2和10.2.0.2，即<saddr=10.3.0.2, daddr=10.2.0.2, iif=A>, 
  如果启用反向路径过滤功能，它就会以<saddr=10.2.0.2, daddr=10.3.0.2>为关键字去查找路由表，
  如果得到的输出接口不为A，则认为反向路径过滤检查失败，它就会丢弃该包。

7.net.bridge.bridge-nf-call-iptables=1
  iptables对规则也会对流经bridge的数据生效

8.同一台主机上的虚拟交换机是不能直接互连的

9.java命令
  java [options] class 二进制文件 [args]
  java [options] -jar jar包文件 [args]
查看具体的args
  java -jar jar包 --help       //能查看到这个jar包的具体用法和参数

10.veth pair
  是一对的虚拟设备接口，一端连着协议栈，一端彼此相连着
  一个端口收到协议栈的数据发送请求后，会将数据发送到对应的端口上去
  可以用来跨越网络命名空间
  可以用来连接一台主机上的两个虚拟交换机
  ip link add xx1 type veth peer name xx2

11.access
（1）接收
  一般只接收 未打标签 的数据帧，则根据端口的pvid给帧打上标签，即插入4字节的vlan id字段
（2）发送
  若帧的vid（vlan id）和端口的pvid（port vlan id）相等，去除标签并发送
  不相等，则不处理

12.trunk
（1）接收
  对于 未打标签 的数据帧，则根据端口的pvid给帧打上标签
  对于 已打标签 的数据帧，则直接接收
（2）发送
  如帧的vid和端口的pvid相等，则去除标签并发送
  不相等则直接发送

13.gre
  ethernet ip gre ip payload
  在已经封装的ip协议基础上，添加gre头部，再封装一层ip，然后再封装ethernet
  是L3层的隧道技术
  本质是在隧道的两端的L4层建立UDP连接 传输重新包装的L3层包头
  gre封装的数据包基于 ip路由表 进行路由的

14.当在zabbix中添加新的oid，一定要先用snmpget看看有没有数据，snmpwalk有数据没用，因为可能没有到底

15.模拟cpu高负载
  cat /dev/urandom | gzip -9 | gzip -d > /dev/null        //当需要更高的负载，则可以继续压缩解压

16.SPAN（switch port analyzer，交换机的端口镜像技术）
  利用SPAN技术，可以把交换机上的某些端口的数据流 copy 一份，发往到指定端口

17.如何获取交换机上其他端口的流量：
（1）SPAN技术
（2）利用arp欺骗攻击
（3）mac地址泛洪

18. shell中  --  表示选项的结束，即后面的都当参数处理

19.set 用于设置shell
  set [-+选项] [-o 选项] [参数]
  set -- arg1 即重置此shell的位置参数（$1=arg1）

11.for xx                  //for后面只有一个变量名，表示遍历位置参数
    do
       echo $xx
    done

12.6种名称空间
  uts（UNIX Timesharing System）                    //主机名和域名
  net                                               //网络，主要用于实现协议栈的隔离
  ipc                                               //进程间通信的
  user                                              //用户
  mnt（mount）                                      // 挂载文件系统的
  pid                                               //进程 id 的

13.查看网卡的带宽
  dmesg | grep xx

14.当添加了新的动态库目录后，需要更新动态库缓存：ldconfig        //例如在安装了guacamole后

15.非交互式执行命令，当需要多次输入，可以利用如下方式实现：
  echo -e "xx\nxx" | passwd root 
  
16.用容器启动ftp时，需要把网络模式设为netwoek，否则客户端无法用被动模式连接ftp服务器

17.tcp中用序列号标识数据段
   当所以序列号是递增的，当恢复ACK=n时，表示序列号<=n的数据段都收到了
   当数据段长度为0时，即只有头部，没有数据时，回复的ACK序列号就不用增加
   在建立连接和断开连接阶段，为什么ACK序列号都加1，这是协议中定义的规定
   
18.\r\n 和 \n 区别：
  在windows操作系统中，回车换行：\r\n
  在linux操作系统中，回车换行：\n
  大部分基于文本的协议，如http等，回车换行：\r\n
  
19.HTTP 1.0 和 1.1 的区别
（1）连接时长
	1.0 每次请求建议一个TCP，服务器完成处理后，立即关闭连接
	1.1 支持长连接（keep-alive），一次连接可以发送多次请求
	
（2）1.1增加Host字段

20.建立tcp连接
  exec FD<>/dev/tcp/HOST/PORT		//会在 /proc/self/fd/ 目录下生成一个描述符
  
21.模拟http请求
（1）http/1.0
	exec 8<>/dev/tcp/10.0.36.1/80
	echo -n -e "GET / HTTP/1.0\n\n" >&8
	cat <&8
或	echo -n -e "GET / HTTP/1.0\n\n" | nc 10.0.36.1 80

（2）http/1.1
	echo -n -e "GET / HTTP/1.1\nHost:10.0.36.1\n\n" >&8
	
#备注：\n\n 表示结束
#当时windows等系统，\n 需要替换为 \r\n

22.printf 
（1）相当于 echo -n -e
（2）printf "%016x" val
	16 —— 字宽为16
	0 —— 不足的用0补齐
	x —— 转换为16进制输出（输出的结果中没有16进制的标记）
（3)转义字符：\ （转译成ascii码，如：\n，转换成换行符，其实就是一个ascii码，是一个字节）
	\数字        //表示后面的数字是八进制，然后进行转换
	\x数字       //表示后面的数字是十六进制，然后进行转换
#如果后面的数字太大，只取能够转换成ascii的数字值，其余的不做转换

###############################################################################