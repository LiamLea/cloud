###############################################################################
补充

1.查看容器与真机绑定的端口号
  docker port xx		//xx为容器ip

2.查看容器使用的存储卷
  docker inspect -f {{.Mounts}} xx		

3.启动容器时利用 --net=xx 指定使用的网络模式

4.如果使用虚拟交换机，虚拟网卡会创建一对，一个在虚拟机中，一个在虚拟交换机上

5.如果虚拟机使用nat桥，可以在宿主机上查看nat的规则：iptables -t nat -vnL

6.桥接模式和nat模式区别：
  都是bridge模式
  桥接模式不能与不同网段的通信(需要虚拟一个路由器），nat可以

7.有两种存储卷
（1）Dokcer-managed volume（由docker自动设置宿主机目录，目录为/var/lib/docker/volumes/容器id/_data)
  -v 容器目录
（2）Bind-mount volume
  -v 宿主机目录:容器目录

###############################################################################
基础

2，docker-ce
  配置文件：/etc/docker/daemon.json

3.docker镜像加速（docker cn 或者 阿里云加速器 或者 中国科技大学）
#vim /etc/docker/daemon.json
  {
      "registry-mirrors": ["http://registry.docker-cn.com"]
  }

4.在容器中跑任何程序都不能运行在后台，否则容器会认为程序终止了，容器也就会结束

###############################################################################
docker镜像

1.镜像采用分层构建机制
（1）最底层为bootfs
    用于系统引导的文件系统，包括bootloader和kernel，容器启动后会被卸载以节省内存
（2）上面的所有层整体称为rootfs     	//上面的层，包括基础层（比如有centos系统层等）
    表现为容器的根文件系统，在docker中rootfs只挂载为"只读"模式，而后通过"联合挂载"技术额外挂载一个"可写"层
（3）最上层为"可写"层
    所有的写操作，只能在这一层实现，如果删除容器，这个层也会被删除，即不会发生变化
（4）分层的优点
  某些层可以进行共享，所以减轻了分发的压力（比如，底层是一个centos系统，可以将底层与tomcat层或nginx层联合，提供相应的服务）

2.docker镜像使用的文件系统是overlay2

3.docker registry
  一个registry可以存在多个repository（一般一个软件有一个repository，里面存储该软件不通版本的镜像）
  repository可分为"顶层仓库"和"用户仓库"
  用户仓库名称格式：用户名/仓库名

4.打包镜像
  可以打包多个镜像
  打包镜像只指定仓库，会将该仓库所有的镜像都打包
  打包镜像指定仓库和标签，只会打包指定镜像
  打包镜像指定镜像id，只会打包该镜像，不会包括该镜像的仓库和标签

###############################################################################
docker网络模式

1.bridge模式（是一个nat桥）
  有一个虚拟交换机dokcer0，所有的容器都与docker0相连，通过宿主机路由出去

#修改bridge所在的网段：vim /etc/docker/daemon.json
  {
    "bip": "192.168.0.11/24"           //指定docker0桥的ip地址和其掩码
  }

2.host模式
  新创建的容器与宿主机共享一个netns
  --network host

3.container模式
  新创建的容器和已经存在的一个容器共享一个netns
  --network container:xx         //xx为已经存在的容器的名字

4.none模式
  使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。
  也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等

5.overlay模式
  可以实现容器的跨主机通信，host模式也可以
  工作方式：需要创建一个consul的服务容器，提供ip地址池，比如10.0.9.0/24之类的
            容器的从consul获取ip
            获取完了后，会通过eth1进行通信
  工作原理：通过隧道的方式，源地址和目标地址不变
            再封装一层四层和三层报文，源地址为源宿主机地址，目标地址为目标宿主机地址
            然后再进行二层等报文的封装779

6.macvlan模式（实现容器跨主机通信）

7.修改docker进程监听的端口，可以连接远程的docker服务端
#vim /etc/dokcer/daemon.json
  {
    "hosts": ["tcp://0.0.0.0:2222","unix:///var/run/dokcer.sock"]         //默认只监听本机的docker.sock套接字
  }

  docker -H xx:2222 ps

8.创建docker网络
  docker network create -d 驱动 --subnet "xx" --gateway "xx" 网络的名字

###############################################################################
macvlan通信     //子网掩码越长，路由优先级越高

1.创建macvlan网络
  docker  network create -d macvlan --subnet 10.0.36.0/24 \
  --ip-range 10.0.36.192/27 --aux-address 'host=10.0.36.223' \         //aux-address就是排除的ip地址，即不会进行分配
  --gateway 10.0.36.254  -o parent=ens34 mynet

2.创建一个新的macvlan接口，用于连接host和container
  ip link add mynet-shim link ens34 type macvlan mode bridge     
  ip addr add 10.0.36.223/32 dev mynet-shim
  ip link set mynet-shim up

3.添加路由信息
  ip route add 10.0.36.192/27 dev mynet-shim

###############################################################################
