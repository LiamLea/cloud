###############################################################################
补充

1.查看容器与真机绑定的端口号
  docker port xx		//xx为容器ip

2.查看容器使用的外部存储
  docker inspect xx		//查看   "Mounts":  这一项 

3.启动容器时利用 --net=xx 指定使用的网络模式

###############################################################################
基础

2，docker-ce
  配置文件：/etc/docker/daemon.json

3.docker镜像加速（docker cn 或者 阿里云加速器 或者 中国科技大学）
#vim /etc/docker/daemon.json
  {
      "registry-mirrors": ["http://registry.docker-cn.com"]
  }

4.在容器中跑任何程序都不能运行在后台，否则容器会认为程序终止了，容器也就会结束

###############################################################################
docker镜像

1.镜像采用分层构建机制
（1）最底层为bootfs
    用于系统引导的文件系统，包括bootloader和kernel，容器启动后会被卸载以节省内存
（2）上面的所有层整体称为rootfs     	//上面的层，包括基础层（比如有centos系统层等）
    表现为容器的根文件系统，在docker中rootfs只挂载为"只读"模式，而后通过"联合挂载"技术额外挂载一个"可写"层
（3）最上层为"可写"层
    所有的写操作，只能在这一层实现，如果删除容器，这个层也会被删除，即不会发生变化
（4）分层的优点
  某些层可以进行共享，所以减轻了分发的压力（比如，底层是一个centos系统，可以将底层与tomcat层或nginx层联合，提供相应的服务）

2.docker镜像使用的文件系统是overlay2

3.docker registry
  一个registry可以存在多个repository（一般一个软件有一个repository，里面存储该软件不通版本的镜像）
  repository可分为"顶层仓库"和"用户仓库"
  用户仓库名称格式：用户名/仓库名

4.打包镜像
  可以打包多个镜像
  打包镜像只指定仓库，会将该仓库所有的镜像都打包
  打包镜像指定仓库和标签，只会打包指定镜像
  打包镜像指定镜像id，只会打包该镜像，不会包括该镜像的仓库和标签

###############################################################################
docker网络模式

1.bridge模式
  有一个虚拟交换机dokcer0，所有的容器都与docker0相连，通过docker0路由出去

2.host模式
  如果启动容器使用host模式，那么该容器不会获得一个独立的Network Namespace，而是和宿主机共有一个
  容器不会虚拟出自己的网卡，配置自己的ip等，而是使用宿舍机的ip和端口，其他的如文件系统还是隔离的

3.container模式
  这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace

4.none模式
  使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。
  也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等

5.overlay模式
  可以实现容器的跨主机通信，host模式也可以
  原理：需要创建一个consul的服务容器，提供ip地址池，比如10.0.9.0/24之类的
            容器的从consul获取ip
            获取完了后，会通过eth1进行通信

6.macvlan模式（实现容器跨主机通信）

###############################################################################